Technique : base("LightGridCommon") =
{
	Language = "HLSL11";
	
	Pass =
	{
		Common = 
		{
			cbuffer GridParams : register(b4)
			{
				// Offsets at which specific light types begin in gLights buffer
				// Assumed directional lights start at 0
				// x - offset to point lights, y - offset to spot lights, z - total number of lights
				uint3 gLightOffsets;			
				uint gNumCells;
				uint3 gGridSize;
				uint gMaxNumLightsPerCell;
				uint2 gGridPixelSize;
			}
			
			float convertToNDCZ(float viewZ)
			{
				return -gNDCZToWorldZ.y + (gNDCZToWorldZ.x / viewZ);
			}
			
			float calcViewZFromCellZ(uint cellZ)
			{
				// TODO - Need better Z distribution. Currently I uniformly distribute in view space, but this
				// results in very elongated cells along Z
				float viewZ = gNearFar.x + (gNearFar.y - gNearFar.x) * cellZ / (float)gGridSize.z;
				
				return -viewZ;
			}
			
			uint calcCellZFromViewZ(float viewZ)
			{
				// TODO - Need better Z distribution. Currently I uniformly distribute in view space, but this
				// results in very elongated cells along Z
				uint cellZ = min((gGridSize.z * (-viewZ - gNearFar.x))/(gNearFar.y - gNearFar.x), gGridSize.z);
				
				return cellZ;
			}
			
			uint calcCellIdx(uint2 pixelPos, float deviceZ)
			{
				// Note: Use bitshift to divide since gGridPixelSize will be a power of 2
				uint2 cellXY = pixelPos / gGridPixelSize;
				uint cellZ = calcCellZFromViewZ(convertFromDeviceZ(deviceZ));
				
				uint cellIdx = (cellZ * gGridSize.y + cellXY.y) * gGridSize.x + cellXY.x;
				return cellIdx;
			}
		};
	};
};

Technique : base("LightGridCommon") = 
{
	Language = "GLSL";
	
	Pass =
	{
		Common = 
		{
			layout(binding = 4, std140) uniform GridParams
			{
				// Offsets at which specific light types begin in gLights buffer
				// Assumed directional lights start at 0
				// x - offset to point lights, y - offset to spot lights, z - total number of lights
				uvec3 gLightOffsets;			
				uint gNumCells;
				uvec3 gGridSize;
				uint gMaxNumLightsPerCell;
				uvec2 gGridPixelSize;
			};
			
			float convertToNDCZ(float viewZ)
			{
				return -gNDCZToWorldZ.y + (gNDCZToWorldZ.x / viewZ);
			}
			
			float calcViewZFromCellZ(uint cellZ)
			{
				// TODO - Need better Z distribution. Currently I uniformly distribute in view space, but this
				// results in very elongated cells along Z
				float viewZ = gNearFar.x + (gNearFar.y - gNearFar.x) * cellZ / float(gGridSize.z);
				
				return -viewZ;
			}
						
			uint calcCellZFromViewZ(float viewZ)
			{
				// TODO - Need better Z distribution. Currently I uniformly distribute in view space, but this
				// results in very elongated cells along Z
				uint cellZ = min(uint((gGridSize.z * (-viewZ - gNearFar.x))/(gNearFar.y - gNearFar.x)), gGridSize.z);
				
				return cellZ;
			}
			
			int calcCellIdx(uvec2 pixelPos, float deviceZ)
			{
				// OpenGL uses lower left for window space origin, we use upper-left
				#ifdef OPENGL
					pixelPos.y = gViewportRectangle.w - pixelPos.y;
				#endif
			
				// Note: Use bitshift to divide since gGridPixelSize will be a power of 2
				uvec2 cellXY = pixelPos / gGridPixelSize;
				uint cellZ = calcCellZFromViewZ(convertFromDeviceZ(deviceZ));
								
				int cellIdx = int((cellZ * gGridSize.y + cellXY.y) * gGridSize.x + cellXY.x);
				return cellIdx;
			}
		};
	};
};